исключения
механизм информирования об ошибках и их обработки

исключения - объекты подкласса Exception
есть встроенные классы, можно писать свои

!!! пробелы в irb важны

бэктрейс(массив строк) - цепочка, показывающая что откуда было вызвано и какое действие привело к ошибке

иcключения "выбрасываются"

rescue для обработки исключения 
begin
<code>
rescue
puts "обработка исключения""
end

!!если между begin и rescue возникает исключение, то выполняется код после rescue

!!!получить данные объекта класса Exception
#обработать все эксепшены 
rescue Exception # == rescue
#обработать только указанный класс (наследник класса Exeption)
rescue <ObjectException> => e #переменная, в которую будет помещен объект класса Exception (ObjectException - конкретный тип ошибок)

примеры
rescue
rescue StandartError
rescue NoMemoryError => e
--

!!! вывод объект через интерполяцию
e.inspect

!!! вывод бэктрейс
e.backtrace.inspect

!!! вывод только сообщение у объекта класса эксепшн
e.message

если есть код, после обработки исключения(после end), то он выполнится
без обработки(код после end) не выполнится

??? как в irb вызвать перечень объектов(подклассов) класса Exception

можно защищать код несколькими rescue для обработки разных типов ошибок

!!! обрабатываем только исключения, которые знаем как обрабатывать

!!! выбросить исключение повторно (запись в лог с последующим выбросом исключения и т.п.)
raise <arguments>
примеры
raise
raise "message"
raise <ClassError>, "message" #ClassError может быть встроеный или свой
--
!!! простое объявление метода без класса - можно вызвать метод в irb

!!! повторить попытку несколько раз (вызывается в блоке recue)
retry

управление передается снова в блок begin или начало метода

!!! нужно делать count и условие
пример
attempt = 0
rescue
attempt =+ 1
retry if attempt < 3
end
---

!!!выделить код, который будет выполнен с ошибкой или без (вызывается в блоке recue)
ensure

!!! сначала пишем методы, потом добавляем переменные и пр.

!!! при появлении исключения, объекты не создаются и память не занимается

====
regexp's
Регулярные выражения

!!!регулярные выражения - шаблоны/паттерны(сравнивать, искать вхождения подстроки, замену подстроки по шаблону и т.п.)

!!! задаются /<regexp>/

. любое количество символов
+ хотябы 1 символ
* ноль или более вхождений
\d цифра
[] знак ([a],[.],[a-z],[a-zA-Z],[^ab]...)
^ начало строки
$ конец строки
{<number>} количество вхождения

!!!сравнение с шаблоном ("" =~ regexp) 
=~ #=> совпадает
!~ #=> не совпадает

??? !=~ работает но как это понять

возвращает номер позиции вхождения регулярного выражения (паттерна) с строку

символы могут просто быть добавлены в regexp
пример
/.+@.'.'./

!!!можно указывать последовательности, устанавливать обязательное условие(цифра/буква,количество,интервал расположение...) ...

!!! rubular.com
!!! pickaxe

у регулярных выражений есть модификаторы
(ставятся после закрывающей /)
пример
/[а-яА-я]{1}\d{3}[а-яА-я]{2}/i

i нечувствительность к регистру

!!! рефакторинг (перемещение методов в private/protected, создание констант... и т.д.)