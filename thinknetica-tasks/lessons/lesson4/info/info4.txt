!!! ментальное программирование
Формулировать код на обычном языке, разработка через создание комментариев описывающих действия.
Затем пошагово пережу комментарии в код.
После, проверка кода в irb и дописывание недостающих частей (инициализация, методы, константы, ...)

!!!самодокументированный код

Программирование методом снаружи-внутрь - сначала методы, потом их реализация

Применение идиом в Ruby.
Если есть методы, которые делают что-то важное или изменяют состояние объекта, то их можно так описывать.
<methods>! 
"bang-методы"

Метод-предикарт. 
<method>?
Возвращает true/false

Нарушение контракта.
Т.е. если клиентский код нарушает логику задачи выполнением каких-либо методов либо последовательности работы метода.
пример
#запустить двигатель, если он не запущен
#нарушение контракта в том, что можно запустить двигатель у объекта класса авто с уже запущенным двигателем
#решение
#перенос метода запуска двигателя в блок private

Все методы public до изменения области их видимости private/protected

Числа в коде, которые не несут какого-то смысла называются "магические числа"
Нужно выносить в константы или методы
пример
current_rpm = 700 #=> 700 магическое число

!!! константа объявляется называнием переменной-константы апкейсом
пример
INITIAL_RPM = 700

также нарушением инкапсуляции (сокрытия реализации) будет возможность установки значения напрямую для инстанс-переменной, если ей присваивается значение через метод
пример
метод accessor , т.е. возможность установки значения напрямую, а не через метод
Решение
разделить метод accessor на reader и writer и разнесение по блокам puplic/private

!!!интерфейс класса - публичные методы класса

наследование позволяет наследовать методы, свойства, данные и т.д.

убирать дублирование кода DRY (don't repeat yourself)

полиморфизм - переопределение поведения в подклассах
например(метод установки rpm вместо константы)
объявить в подклассе аналогичный метод объявленный в классе-родителе

переопределяемые методы должны дыть в аналогичных областях видимости
public-public, protected-protected

protected
!!!методы области видимости protected доступны в классах и подклассах

переопределять можно методы в public и protected (Ruby позволяет и в private, но не рекомендуется(по соглашению). В остальных языках переопределение в private недопустимо)

ньюанс для переопределения методов в классах-потомках методов из private класса-родителя. Несмотря на наследование.
через self (обращение к самому себе) нельзя обратиться к методу базового класса находящемуся в private
пример ошибки
class Car
  private
  def start_engine!
  end
end
class Truck
  def wrong_method
    self.start_engine!
  end
end

работающий пример
class Car
  private
  def start_engine!
  end
end
class Truck
  def wrong_method
    start_engine!
  end
end
--

img1.jpg

неполное переопределение(т.к. не 1 в 1)
используется конструкция super
т.е. super вызовет весь код из метода родительского класса(супер-класса).
если есть аргументы, то super()
пример
class Car
  def start_engine
    start_engine if engine_stopped?
  end  
  protected
end
class Truck
  def start_engine
    puts "Click"
    super
    puts "Wroom!!!"
  end 
  protected
end
---

передача методу классу объекта класса 
пример
class Car
end
class Driver
  def drive(car)
    # сесть в машину
    # запустить двигатель
    # передаю объект car в качестве параментра
    car.start_engine
    # тронуться с места
  end
end

вызов
driveer = Driver.new
driver.drive(car)
#=> nil

car.current_rpm
#=> 700

driver.drive(sport_car)
#=> Click
#=> Wroom!!!

driver.drive(truck)
#=> nil

truck = Truck.new
driver.drive(truck)
#=> 500

------
!!!Duck Typing (концепция "утиная типизация". Если объект крякает как утка, то мы считаем, что он утка)
пример (из предыдущего примера)
car.start_engine

----
!!! В Ruby не важны типы при передаче параметра т.е. параметром может быть любой объект, а есть у него методы или нет зависит от того есть ли они в описании его кода или его классе-родителе.


Разделение программы по файлам (классов по файлам)
car.rb
truck.rb
sport_car.rb

файл выполняется построчно
подключение файлов описывается в отдельном файле
либо require '<абсолютный путь>' #в Rails
либо require_relative '<относительный путь>'

пример (main.rb)
require_relative 'car'
require_relative 'truck'
require_relative 'sport_car'
truck = Truck.new
truck.start_engine
puts "Truck RPM: #{truck.current.rpm}"
car = Car.new
car.start_engine
puts "Car RPM: #{car.current.rpm}"
sport_car = SportCar.new
sport_car.start_engine
puts "Sport Car RPM: #{sport_car.current.rpm}"




!!! subl <filename> создает файл и сразу открывает
---
1. задача разбиваю на блоки, блоки на элементы, элементы на данные и действия (атомизация)
2. описываю каждый шаг комментарием
3. кодом реализую пошагово комментарии
4. irb проверка. дописываю недостающие части
5. рефакторинг кода (изменение структуры кода без изменения функциональности(поведения): удаление комментариев, перенос методов в приватные блоки, использование методов вместо констант, DRY(don't repeat yourself) убирать дублирующийся код, ...)
---
